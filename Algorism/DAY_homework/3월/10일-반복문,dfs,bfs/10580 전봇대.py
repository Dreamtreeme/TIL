# 문제 읽기
'''
현우는 길을 가다가 전선들이 복잡하게 꼬여있는 전봇대 두개를 보았다.
두 전봇대는 높이가 매우높으며, N개의 팽팽한 전선으로 연결되어 있었다.
두 전선이 끝점이 같은 경우는 없으나 중간에 교차하는 경우가 있었다.
세개 이상의 전선이 하나의 점에 만나지 않는다. 총 몇개의 교차점이 있을까
'''
# 자료구조
'''
1. 테스트케이스 T
2. N: 전선의 개수 (1 <= N <= 1000)
3. N개의 줄에 두 양의 정수 A,B (1 <= A,B <= 10000) A,B는 전선의 높이

'''
# 알고리즘설계

'''
교차하는 경우를 생각해본다
케이스 1 
A1과 A2 가 주어진다. 그리고 A2가 높을떄 B1은 A1보다 높고 B2는 A2보다 낮다.
즉
A와 B의 높이 사이에 포함되는 전선들은 모두 교차점 1개씩 가진다
그래서 제일 높이 차이가 큰 전선을 찾고 그 사이에 있는 전선들의 개수를 세면된다.
리스트를 만든후 (A,B)로 저장
단 A의 값이 높은 순으로 정렬한다.
반복문을 돌며 B에 대해 다음 전선 B가 높으면 continue 낮으면 교차점을 +1
단 리스트의 첫번째 인덱스 비교가 끝나면 다음 인덱스는 i+1부터 시작해야함
리스트를 만들고 N번만큼 append한다.
그리고 정렬을 한다.
그리고 반복문을 돌며 교차점을 찾는다.
총 시간복잡도는
O(2N^2) = 2000000 이므로 충분히 가능하다.

'''

T= int(input())
for tc in range(1, T+1):
    N = int(input())
    lines = []
    for _ in range(N):
        A, B = map(int, input().split())
        lines.append((A,B))
    # A가 높은 순으로 정렬
    lines.sort(key=lambda x: x[0])
    result = 0
    for i in range(N-1):
        for j in range(i+1, N):
            if lines[i][1] > lines[j][1]:
                result += 1
    print(f'#{tc} {result}')

# 예외케이스 분석
