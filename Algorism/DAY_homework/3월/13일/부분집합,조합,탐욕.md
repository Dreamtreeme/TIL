## 부분집합

원래는 비트연산으로 품, 재귀호출로 풀어보겠음

부분집합은 공집합부터 전체집합까지 총 2**n개의 집합이 나옴

집합에서 부분 집합을 찾아내는 구현 방법
1. 완전탐색
    {"min","co","tim"}
    모든 케이스 출력해보면 피보나치 수열처럼 1 331이 나옴
    def recur():
    if 3명이 판단했으면:
        return
    recur(포함하는경우)
    recur(포함하지 않는경우)
2. binary countiong
    원소 수에 해당하는 N개의 비트열을 이용한다

    for i in range(1<<len(arr)):
        그리고 부분집합 마다마다 각 자릿수의 상태를 확인해 유무를 확인한다
        for j in range(len(arr)):
            if i&(1<<j)

        예시) i=2 이걸 이진수로 표현하면 10  10에서 1을 0,1,2,3 만큼 왼쪽으로밀면
        1, 10, 100, 1000, 이 나오고 10과 자릿수를 비교한다. 4번 비교하는데 최대 4개까지 포함된다.


## 순열과 조합
- 순열 5명중 1,2,3등뽑기
  - ABC와 CBA는 다른 경우이다.

- 조합: 5명중 3명 뽑기
  - ABC와 CBA는 같은 경우이다.


## 탐욕 알고리즘

완전 검색이 안될때 가장 좋아 보이는 선택지로 결정하여 답을 도출하는 알고리즘

1. 어떤 문제가 그리디 문제인가

2. 무조건 최적해만 선택하면 되나?
-------------------------
그리디 문제 푸는 법

조건을 확인하기전에 선행되어야 할 것
1. 규칙성을 찾아야한다.
    - 규칙을 못찾으면 못품
-----------
### 그리디로 풀 수 있는 조건

1. 탐욕적 선택 조건 (greedy choice property)
   - 각 단계의 최적해 선택이 이후 단계 선택에 영향을 주지 않는다.
  
2. 최적 부분 구조 (Optimal substructure)
   - 각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이어야한다.


동전문제 예시
    첫번째 단계: 500원으로 가능한 만큼 주자
    두번째 단계: 남은 동전 중 가장 큰 동전인 100원
        => 각 단계를 진행하면서 규칙이 유지

    최적 부분 구조의 증명
    [명제] 가장 큰 동전부터 고르면 최소 동전 수가 나온다
    [간접 증명]
        - 가장 큰 동전부터 고르면 최적해가 안나온다.가정
        - 작은 동전부터 골랐을 때 최적해가 나온다 라고 가정
        - 더 작은 수로 나눴을 때 최소몫이 나올 수 있다.
          - 가정이 모순 발생
    반례 를 찾아보는게 증명이 어렵다.


sort 함수는 sort(key=lambda x: x[0]) 에서 각 원소번째 기준으로 정렬할수있음
sort(key=lambda x: (x[1]/x[0]), reverse=True)