"""
핵심 아이디어
우선 비율이 제일 중요합니다.
코드 해석표를 보면 0,1,0,1 순서대로 비율표가 있습니다.
여기서 우리는 배열에서 암호코드 찾는 위치를 1로 지정할거기 때문에
앞의 0 갯수 비율은 무시해줍니다.

그다음 배열의 행마다 특징이 
0으로만 이뤄진 케이스1
0과 암호문으로 이뤄진 케이스2 ex) ["000암호코드000"]
0과 암호문n개로 이뤄진 케이스3 ex) ["000암호코드000암호코드00...]
로 구분됩니다. 우선 set함수로 이 케이스3개로 구분해줍니다.

그리고 각 행마다 이진수로 치환해 줍니다.
format(int(i,16), "b").lstrip('0')
이 뜻은 16진수를 2진수로 치환하고 왼쪽 0을 다 날린다는 뜻입니다.
왼쪽만 날리는 이유는 "암호코드000암호코드00... 이 구문처럼
암호코드의 끝을 알리는 지점이 0이기 때문입니다.
이게 가능한 이유는 암호표 뒷자리가 모두 1로 끝나기 때문에 이진수로 변환해도
절대 0으로 끝나지 않습니다.

이제 각 행마다 1,0,1 의 비율, 7비트 암호 갯수 및 홀짝구분, 홀짝 값 변수, 
케이스2 이후 케이스3이 나왔을때 중복되는 값을 저장해놓는 변수를 생성합니다.
그리고 이진수에 반복문을 돌려 각 자리마다 검사합니다.

이때 핵심은
1,0,1의 비율을 차례대로 조건문을 설정해야합니다.
그래야 비율이 다 채워지고 암호문에 써놓은 비율중 하나가 나오기 떄문입니다.
이제 마지막 1의 비율이 다 채워지고 4번째 조건문으로 건너뛰었다는 이야기는
7비트짜리 암호문 1개가 완성되었다는 의미입니다.

암호문 딕셔너리를 이용해 값을 구하고 그 값을 유효검사 변수에 넣어줍니다.
그리고 홀짝을 구분해 홀수 짝수 변수에 값을 더해주고 비율은 다음 암호문을 위해 초기화 시켜줍니다.
만약 홀짝구분변수가 8이라면 암호문이 끝난거니
조건1 홀수*3+짝수+마지막값 이 10의 배수인가
조건2 전에 검사한 값에 포함되는가
를 구분해 정답에 값을 추가해 줍니다.
이제 암호코드1개가 끝났으니 홀,짝,암호,횟수를 전부 초기화하고 다음암호코드로 넘어갑니다.


"""


ratio = {(2, 1, 1): 0, (2, 2, 1): 1, (1, 2, 2): 2, (4, 1, 1): 3, (1, 3, 2): 4, (2, 3, 1): 5,
         (1, 1, 4): 6, (3, 1, 2): 7, (2, 1, 3): 8, (1, 1, 2): 9} # 맨앞 0을 제외한 2번,3번,4번 칸의 비율

T = int(input())
for case in range(1,T+1):
    N, M = map(int, input().split())
    code = list(set([input() for _ in range(N)])) 
    answer = 0
    temps = [] # 유효 처리가 끝난 암호문 넣을곳
    for i in code: 
        binarycode = format(int(i,16), "b").lstrip('0')
        n1 = n2 = n3 = 0 # 비율 초기화
        cnt = 0 # 7비트 암호 갯수 및 홀짝구분
        even = odd = 0 # 홀짝의 합 저장값 초기화
        overlap = '' # 코드를 모았다가 유효검사가 끝난곳에 넣을 변수 및 검사할 변수
        for j in binarycode: #j 각 2진수 코드의 자리값
            if j == "1" and n2 == 0: # 1을 만났는데 n2가 0이면 처음 시작임
                n1 +=1
            elif j == "0" and n1 != 0 and n3 == 0 : # 0을 만났는데 n1이 0이아니고 n3가 0이면 n2시작
                n2 +=1
            elif j == "1" and n2 !=0: # 다시 1을 만났는데 n2가 0이아니면 n3시작
                n3 +=1
            elif j == '0' and n3 >=1 : # 위 3조건 다 지나치고 0이다시나올때 n3가 1이상이면 암호문 끝난거임
                cnt+=1
                r = min(n1,n2,n3) # r n1,2,3의 최소비율 공약수
                nums = ratio[(n1//r,  n2//r, n3//r)]  # 공약수로 나눈 값은 비율 딕셔너리의 키값
                overlap+= str(nums) 
                if cnt ==8 : # 7비트 암호 갯수가 8개면 끝난거
                    # 마지막 nums는 정상유무 값이므로 그냥 넣어도됨
                    if (odd*3+even+nums)%10==0 and overlap not in temps: # 10배수 조건을 만족하고 유효처리 끝난 코드인지 확인
                        answer += odd+nums+even # 유효코드이고 중복안되니 더함
                    temps.append(overlap) # 한번 사용한 유효코드 표시
                    even = odd = 0 #홀수 짝수 초기화
                    cnt = 0 # 횟수도 초기화
                    overlap = '' #암호도 초기화
                elif cnt %2 == 0: # 8자리가 아닐때 짝수라면
                    even += nums
                else: # 8자리가 아니고 홀수라면
                    odd += nums
                n1=n2=n3=0



    print(f'#{case} {answer}')