컴퓨팅 사고력, 완전검색, 그리디

최대한 팁 위주로 공유

### 증가하는 사탕수열 20551

3개 상자 나란히 존재

A,B,C 개씩 사탕이 들어있음

- 변수인지 리스트인지 잘 모름

사탕의 개수를 보아하니 변수로 저장할 가능성이 높음

A<B<C 개이길 바람

목표
0개이상 먹어서 없애버린다
최소 몇개 사탕의 최소값을 구하라

문제 읽기 단계 다음 설계시작
----------------------

- 자료구조
  - 3개의 숫자 + 먹은 개수 만 저장하면 끝
  - 리스트 vs A,B,C 저장

- 알고리즘
  - B는 C보다 작아야한다
    - B를 C보다 작을 때까지 하나씩 감소
      - [검증] 최악의 경우 O(N)이 나오니 조건 확인
      - 3000 까지니 가능하다.
  - B = C-1로 만들어준다

만족할 수 없는 경우면 -1을 출력한다

불가능한 경우
B<2 C<3


### 1953. 탈주범 검거

탈출한지 한시간 뒤 어느 지점으로 은신중

터널끼리 연결이 되어 있는 경우 이동이 가능, 탈주범이 있을 수 있는 위치의 개수를 계산
탈주범은 시간당 1의 거리를 움직일 수 있다.

시작점인 맨홀뚜껑 위치가 정해짐
1.방문체크가 필수
2.시간을 누적하면서 진행

지도 이차원 배열 형태로 입력이 들어옴
-이동 방향: 상하좌우, 델타배열이 생각남
- 이동 못하는 경우
  - 현재 내 위치에서 뚫려있는 곳으로만 가능
  - 다음 위치의 입구가 뚤려있는 곳으로만 가능

DFS경우 재귀호출이 2500번가능, 파이썬은 1000번이기 때문에 못씀
BFS인 경우 시간복잡도
O(V+E) 정점의 갯수 간선의 갯수
정점의 갯수 2500개
간선의 갯수 =4개 *2500 10000개

### 5656 벽돌 깨기
구슬을 쏘아 벽돌을 깨뜨리는 게임

구슬을 좌우 로만 움직일 수 있어서 항상 맨 위있는 벽돌만 깨뜨릴수있다.
벽돌을 숫자 1~9로 표현되며, 구슬이 명중한 벽돌은 상하좌우로 써진 숫자만큼 없어짐
빈 공간이 있을 경우 벽돌은 밑으로 떨어지게 된다.


시뮬레이션 문제는 경우의 수를 다 봐야한다
DFS가능성이 높음

무조건 모두 굴려보아야 정답이 나오고 DFS

현재 기준으로 퍼져나가면서 탐색한다 BFS

### 오늘 배운점
- dfs
  - 보통 재귀함수로 많이 쓰며 특징은 트리를 생각했을때 현재의 정보를 포함한걸 다음 차수로 넘겨서 계산한다
- bfs
  - 보통 while과 deque를 이용하며 같은 차수 안에서 해결함
  
  백준의 알고리즘 구현 유형별로 학습하고 구현해봄. 그리고 swea해봄