## 3월 11일

### 논리
논리는 두가지 
1. Hard Rogic
   - 프로그래밍 언어는 모두 논리학에서 나온것
   - 가정이 거짓이면 전체는 항상 참이됨(모든 논제가 거짓이라는 기반하에 참)
2. soft Rogic: 논리적인 느낌을 주는것
    - 익숙한 상황에서 빠르고
    - 정확하지 않으며 강한 착각을 일으킴

카드뒤집기를 할때 증명이 있고
증명이 참임을 증명하려면
참인 케이스를 확인하는것보다
거짓인 케이스를 확인해보는게 더 빠르다

### 명제
- 2는 짝수이다.
- 3은 짝수이다
- 서울은 대한민국의 수도-> 확률 100퍼
- 강의는 재밌다 ->확률 갈림
- 강사님은 멋있다 -> 확률 갈림
  모두 참과 거짓으로 판별 할 수 있는 문장
  즉 100%확률의 상태여야 한다

p->q
p가 참일때, q도 참이다.

4가 짝수일때, 4의 제곱도 짝수이다.

### 증명방법
1. 대우 증명
    - 4제곱이 홀수라면, 4는 홀수이다.
    - 가정이 거짓 -> 무조건 참이다.
    - 대우명제 참 증명, 원래 명제도 참
2. 직접증명
    - 4가 짝수다 = 4 = 2k
    - 4제곱 = 2k제곱 = 4(k제곱)
    - 4(k^2) 는 4로 나누어 떨어진다 => 짝수다
3. 간접증명
   - 반대 가정: 4^2이 홀수라고 가정
    - 반대가정은 모순이 발생하면 원래명제 참
4. 진리표 그리기

### 로그와 n의 관계
1. n은 2^n의 n이다
2. logn은 2의 몇제곱인지 구하는것이다

### 집합과 집합론

A가 B의 부분집합임을 증명하는방법

2k+1 는 k가 홀수,짝수인경우 2가지가 있다
홀수 는 4t+3 짝수는 4t+1이므로 증명이됨

부분집합같은경우 경우의 수문제에서 많이나옴
순서가있다면 순열, 없다면 조합
nCk -> n!/(n-k)!*k!


- 귀납법
  - 점진적으로 증명하는 방법
  - 특정 사례로 부터 출발해서, 일반적인 규칙을 찾는 방법
  - 기저사례, 귀납가정, 귀납 단계
- 귀류법
  - 어떤 명제가 거짓일 수 없다 라고 가정하고 이로 인해 발생하는 모순을 찾는 방식
  - 예제) (A-B)교집합(B-A) = 공집합
  - 이걸 공집합이 아니다라고 가정
  - 그러면 다른 케이스가 나오는데 각 케이스에 모순이 발생함 모든 케이스에서 모순이 발생해야만 원래 명제가 참

## 기초수식 (젤 중요!!)
T(n/2)+1 -> log n번 하겠구나 k = logn
O(logn)

1. n값이 얼마나 반복되는가
2. 반복마다 연산횟수가 얼마나 증가하는가

### 재귀함수
   - 언제 써야 하는가?
       - N중 반복문이 필요할 때
       - 문제를 작은 문제로 분할 할 수 있을때
         - 대표적인 재귀 접근 방식: 분할 정복
   - 언제 재귀함수에서 return을 써야할까?
     - 작은 문제들의 결과를 큰 문제에서 합쳐야 할때

### 다이나믹 프로그래밍
  - 작은 문제들로 분할해서 푸는 경우가 많은데, 이러면 중복된 문제들이 많이 발생함.
  - 한번 계산해 놓은 결과를 저장해두고 저장된 결과를 재활용하여 중복 계산을 피하자.
  - 메모이제이션, 점화식
  DP 문제인지 파악하기 어려움
  많은 문제를 풀어보아야 한다.