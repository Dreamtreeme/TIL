## 카운팅 정렬(Counting Sort)
    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
    -시간복잡도O(n)

### 제한 사항
#### 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
    - 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다

### 정렬 과정
- ex) [0,4,1,3,1,2,4,1] 배열이 있으면
- count 배열을 준비해두고
- 그 배열에 반복문으로 모든 요소를 돌아 count함

### 누적 카운팅
- 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영

- 새로운 누적카운팅 리스트 생성
- 기존 카운팅 리스트에서 N+N-1...+1 번만큼 요소를 더해줌
- NEW_COUNTS[i] +=NEW_COUNTS[i-1]

## 정렬
- 누적카운팅의 리스트 요소는 각 원본 요소가 놓여질 맨 뒤의 인덱스 번호
- 그렇기 때문에 각 번호를 사용하면 누적카운팅을 감소시킴
- 마지막엔 누적카운팅엔 각 요소의 시작점을 가리키는 인덱스 번호가 남음.
- 새로운 요소를 만들고 기존 카운팅만큼 새 요소를 만들지 않는이유는, 순서가 그대로 유지되려고 이다.

'''
0<= DATA[i] <=4 조건
카운팅정렬은 인덱스 번호로 올 수 없는 리스트엔 사용할 수 없다
인덱스 번호가 100만개 이하면 쓸만함
'''

DATA = [0,4,1,3,1,2,4,1]
N = len(DATA)
COUNTS = [0] * 5 # DATA요소의 최댓값 +1, 각 요소가 중첩되있고, 중첩된 갯수를 세야하기 때문
TEMP = [0]*8 # 최종 결과값을 저장할 리스트
# 1단계 숫자 카운트
for i in range(N): # DATA 리스트의 모든 요소를 순회하며
    COUNTS[DATA[i]] +=1 #각 요소의 숫자를 인덱스 번호로 접근해 그 방에 접근하면 카운팅

print(COUNTS)

# 2단계 누적카운팅
for i in range(1, len(COUNTS)+1):       # COUNTS[i]까지의 합계
    COUNTS[i] += COUNTS[i-1]

print(COUNTS)

# 3단계 정렬단계
for i in range(N-1, -1, -1):# 맨 끝부터 거꾸로 반복문 횟수 한번씩 감소시키며
    COUNTS[DATA[i]] -=1 # DATA[i]까지의 개수 1개 감소
    TEMP[COUNTS[DATA[i]]] = DATA[i] # DATA[i] 까지 차지한 칸 수 중 가장 오른쪽에 DATA[i] 기록



## 완전검색
    - 모든 경우의 수를 전부 만들어놓고
    - 조건에 모든 경우의 수를 검사해보는 방법
    - 무식하지만 최적의 해를 찾는 방법

# 완전탐색 예시
arr=[2,3,7]
for i1 in range(3):
    for i2 in range(3):
        if i1 !=i2:
            for i3 in range(3):
                if i1 != i3 and i2 != i3:
                    print(arr[i1],arr[i2],arr[i3])

# 탐욕 알고리즘
- 일반적으로, 머릿속에 떠오르는 생각을 검증 없이 바로 사용하면 Greedy

## 동작 과정
1. 해선택
2. 실행 가능성 검사
3. 해검사

### 예시
    - 거스름돈 줄이기
    1. 일단 최대값 거스름돈 선택
    2. 실행 가능성 검사 - 거스름돈 보다 거슬러주는 돈이 큰지 검사
    3. 남은 거스름돈이 있는지 검사. 남으면 1번부터다시, 아니면 끝

### 한계점
    - 항상 최대값을 먼저 선택하기 때문에 더 좋은 최적의 해를 찾지 못함
    - 조건1->조건2 식으로 가기때문에 조건1로인해 조건2가 만족할 수 없을때가 있음
