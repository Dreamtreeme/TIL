# 검색

- 저장되어 있는 자료 중에서 원하는항목을 찾는 작업

- 목적하는 탐색 키를 가진 항목을 찾는 것
    - 탐색 키: 자료를 구별하여 인식할 수 있는 키

- 종류
    - 순차검색
    - 이진 검색
    - 해쉬

## 순차검색
- 일렬로 되어있는 자료를 순서대로 검색하는 방법
- 가장 가단하고 직관적인 검색 방법
- 배열, 연결 리스트 등 순차구조로 구현된 자료구조 에서 유용
- 알고리즘 구현쉬움, 대신 대상의 수가 많은 경우 비효율

### 검색 과정
- 첫번째 원소부터 순서대로 비교
- 키 값이 동일한 원소를 찾으면 원소의 인덱스 반환
- 마지막에 이를때 까지 대상 찾지 못하면 검색 실패

- 평균 시간 복잡도 O(n) (n+1)/2
def seq_search(a, n, key):
    for i in range(n):
        if a[i] == key:
            return 1
        return -1

arr = [4, 9 ,11, 24,2,19,7]
print(seq_search(arr, len(arr), 8 ))

### 정렬을 한 경우 검색과정
- 정렬 후 찾는 순서는 오름차순, 내림차순이므로 n을 검색할때
- n의 숫자보다 크거나 작은 경우 그 이후 인덱스는 접근 안해도 됨


## 이진 검색
 - 자료의 가운데에 있는 항목의 키 값과 비교, 다음 검색의 위치결정
 - 업 다운 을 생각하면 편함. 임의의 숫자를 찾을때 우선 숫자의 중간지점 예측, 목표값 비교, 작으면 왼쪽 크면 오른쪽 탐색
 - 단 정렬이 되어 있어야함.

### 이진 검색 구현
- 검색 범위의 시작점과 종료점을 이용하여 검색을 반복 수행
- 이진 검색의 경우, 자료에 삽입 삭제가 발생했을 떄 배열의 상태를 항상 정렬 상태로 유지하는 추가작업이 필요

def binary_search(array, target):
    low = 0
    high = len(array) - 1
    counter = 0

    while low <= high:
        mid = (low + high) // 2  # 중간 값 계산
        counter+=1
        if array[mid] == target:
            return counter
        elif array[mid] > target:
            high = mid - 1  # 왼쪽 범위로 좁히기
        else:
            low = mid + 1  # 오른쪽 범위로 좁히기

    return -1 

## 선택 정렬
    1. 최소값을 찾음
    2. 최소값을 맨 앞 인덱스로 옮김
    3. 이후 나머지 인덱스에 다시한번 최소값 찾음
    4. 찾으면 다시 맨앞 인덱스 앞에 값과 교환

    for i in range(N - 1):      # 기준위치(최소 값을 찾는 구간의 시작 인덱스)
        min_idx = i             # 최소값 인덱스 초기화, 구간의 맨 앞 원소를 최소로 가정
        for j in range(i+1, N):  # 실제 최소값인지 비교하는 위치
            if M[min_idx] > M[j]: # 계속해서 최소값보다 뒤값이 작은지 확인하고 만약 작은값이 발견되면
                min_idx = j # 작은값 인덱스 바꿈
        M[i], M[min_idx] = M[min_idx], M[i] # 인덱스 값이 안바뀌면 그대로, 아니면 바꿈



## 셀렉션 알고리즘
- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 셀렉션 알고리즘이라 한다.
    - 최소값, 최대값 혹은 중간값을 찾는 알고리즘을 의미하기도 한다.

- k번째가 작은수라면 O(kn)의 수행시간을 필요로하기 때문에 효율적



