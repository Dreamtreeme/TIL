# Memoization
    
    메모이제이션은 컴퓨터 프로그램을 실행할떄
- 이전에 계산한 값을 메모리에 저장해서
- 매번 다시 계산하지 않도록 하는 방법

def fibo1(n):
    global memo
    if n >= 2 and memo[n] == 0:
        memo[n] = fibo1(n-1) + fibo1(n-2)
    return memo[n]
### 피보나치 수열 계산 후 메모에 저장
 - 조건으로 n이 1부터는 값이 고정이어서 건너뛰고
 - 메모에 이미 값이 있으면 그값만 리턴
 - 즉 계산을 해놨으면 중복 함수로 안빠지고 무조건 함수 하나만 반환
n = 10  # 원하는 n 값을 설정
memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1


## DP(Dynamic Programming): 다이나믹 프로그래밍

- 동적계획 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.

- 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이요하여 보다 큰 크기의 부분 문제들을 해결하는법

### 피보나치 수 DP적용
- 부분문제 답으로부터 본 문제의 답을 얻을 수 있음

1. f(n) = f(n-1)+f(n-2)....f(0)의 부분구조로 나뉜다
2. 부분 문제로 나누는 일이 끝났으면 가장 작은 부분 문제부터 해를 구한다
3. 구한 해를 테이블에 저장하고 그 해를 이용해 문제를 해결

## 반복적인 구조
def fibo2(n) :
    f = [0] * (n + 1)
    f[0] = 0
    f[1] = 1
    for i in range(2, n + 1) :
        f[i] = f[i-1] + f[i-2]

    return f[n]

print(fibo2(10))

## 깊이우선탐색 DFS
- 비선형구조인 그래프 구조는 그래프로 표현된 모든 자료를 빠짐없이 검색하는 것이 중요함

- 두 가지 방법
- 깊이 우선 탐색
- 너비 우선 탐색

- 미로로 따지면 왼쪽 벽을 짚고 쭉 가서 막히면 그 전 갈림길로 돌아와서 다시 반복
- 후입선출의 구조 스택 사용

### 그래프 방식은 어떻게 저장할것인가

